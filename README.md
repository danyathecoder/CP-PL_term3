# CP-PL_term3
## 1 лабораторная 
### Тема: Операторы ввода/вывода
## 2 лабораторная
### Тема: Создание базовых объектов.

Общие требования к выполнению работы
    1. Создать проект консольной программы.
    2. Создать базовый класс согласно заданию. Все данные класса описать в закрытой секции, все методы класса реализовать как открытые. Создать конструктор по умолчанию и конструктор инициализации. Создать деструктор.
    3. Вне класса должна быть создана дружественная функция, предназначенная для вывода данных объекта на экран.
    4. Для задания значений уникальных номеров использовать или статические члены класса или особую инициализацию членов класса.
    5. Установка значений переменных должна иметь проверку на реальный диапазон значений.
    6. В головной функции создать несколько одиночных экземпляров базового класса. Обработать все экземпляры базового класса с помощью заданного метода дружественного класса. Вывести содержимое переменных экземпляров классов на экран до и после этой обработки.
    7. В головной функции создать массив экземпляров базового класса. Обработать все элементы массива с помощью заданного метода дружественного класса. Вывести содержимое переменных элементов массива на экран до и после этой обработки.

Варианты 7
    Создать класс «Школьник» со следующими данными: id – уникальный номер, name – ФИО, missed – количество пропущенных занятий. Создать дружественный класс «Учитель», в котором реализовать метод установки количества пропущенных занятий.

## 3 лабораторная
### Тема: Перегрузка функций и операторов. Динамическое создание объектов и массивов объектов.

Общие требования к выполнению работы
    1. Создать проект консольной программы.
    2. Создать базовый класс согласно заданию. Все данные класса описать в закрытой секции, все методы класса реализовать как открытые.
    3. Создать конструктор по умолчанию, конструктор инициализации и конструктор копирования. Конструкторы должны выделять память для данных динамически с использованием оператора new.
    4. Создать деструктор, который будет освобождать динамически выделенную память с помощью оператора delete.
    5. Создать в классе методы доступа к одиночному элементу данных объекта (по чтению и записи), отображения данных на экран, преобразования данных объекта (например, сортировки).
    6. Перегрузить операторы-члены класса (согласно варианту):
-- присвоение =;
-- индексация элемента [];
-- инициализация ();
-- унарные арифметические (++);
-- бинарные арифметические (+ или ‑ ) и сравнения (> или < или ==), причем только для однотипных операндов;
    7. Перегрузить дружественные функции-операторы (согласно варианту)::
-- унарные арифметические (--);
-- бинарные арифметические (+ или ‑ ) и сравнения (> или < или ==), причем для разных типов операндов;
-- вывода в поток (<<).
    8. В головной функции создать несколько экземпляров базового класса. Провести вызовы перегруженных функций и операторов. Вывести результаты на экран.
    9. В головной функции динамически создать и проинициализировать экземпляр базового класса. Динамически создать его копию. Выполнить преобразование данных экземпляра базового класса. Вывести содержимое обоих экземпляров на экран. Удалить экземпляры.
    10. В головной функции динамически создать массив экземпляров класса. Каждый из них проинициализировать. Выполнить доступ к элементам данных экземпляров классов. Удалить массивы.
 
Вариант 7
    
Класс 					Двумерный массив (матрица) с элементами типа char.
Операторы-члены класса			сравнения (> и <), причем только для однотипных операндов;
Дружественные функции-операторы	вывода в поток (<<)
Сортировка				нет

## 4 лабораторная
### Тема: Наследование

    1. По полученному базовому классу создать классы наследников по двум разным ветвям наследования (B←P1←P11 и B←P2←P21):
    a) во всех классах должны быть свои данные (характеристики объектов), расположенные в private или protected секциях;
    b) во всех классах создать конструкторы инициализации объектов для всех классов (не забыть про передачу параметров в конструкции базовых классов);
    c) во всех классах создать деструкторы;
    d) во всех классах создать метод вывода объекта на экран (всех его параметров);
    e) остальные методы создавать по необходимости.
    2. Создать класс с множественным наследованием (P11 ← P3 → P21). Создать в этом классе выше описанные функции (в коде функций не использовать доступ к данным через оператор разрешения зоны видимости ::). Наследование выглядит следующим образом: базовый имеет два наследника, каждый из которых имеет по одному наследнику, в свою очередь у этих наследников есть единый т. е. получается "кольцо"

    3. В головной функции создать экземпляр класса P3. Вывести содержимое экземпляра класса P3 на экран. Проверить, что получится, если не будет использовано виртуальное наследование.
    4. Все возможные данные вводятся с клавиатуры с проверкой на корректность. Данные для объектов вводятся в main и передаются в объекты классов через конструкторы. Память выделять динамически.

Вариант 22: Волейбол

## 5 лабораторная
### Тема: Виртуальные функции и абстрактные классы

Общие требования к выполнению работы
    1. Базовый класс должен быть абстрактным.
    2. По полученному базовому классу создать классы наследников по двум разным ветвям наследования (B←P1←P11 и B←P2):
        a. во всех классах должны быть свои данные (характеристики объектов), расположенные в private или protected секциях;
        b. во всех классах создать конструкторы инициализации объектов для всех классов (не забыть про передачу параметров в конструкции базовых классов);
        c. во всех классах создать деструкторы;
        d. остальные методы создавать по необходимости.
    3. Создать в базовом классе чисто виртуальные функции расчета (например, расчет площади фигуры и т.п.) и вывода объекта на экран (всех его параметров). Выполнить реализацию этих виртуальных функций в классах наследниках.
    4. Задать в базовом классе деструктор как виртуальный.
    5. В головной функции динамически создать массив указателей на базовый класс. Заполнить массив указателями на динамически создаваемые объекты производных классов (P1, P11, P2). Для каждого элемента массива проверить работу виртуальных функций. Удалить из памяти динамически выделенные объекты.
    6. Всё взаимодействие с экземплярами производных классов производить через указатель на базовый класс.
    7. Сгенерировать диаграмму классов

Варианты:
Варианты остаются с 4 лабораторной работы.

## 6 лабораторная
### Тема: Шаблоны функций и классов

Общие требования к выполнению работы
    1.  Создать проект консольной программы.
    2. Создать шаблонную функцию или класс согласно заданию.
    3. Реализовать явную специализацию шаблонной функции или класса для строк символов (char *).
    4. В шаблонных классах использовать стандартные типы и аргументы по умолчанию. Данные в шаблонных классах хранить в статическом массиве. Набор методов класса должен обеспечить основные операции с элементами объекта (добавление, удаление, поиск, просмотр, упорядочивание и т.п.) и операции над однотипными объектами (сравнение, сложение и т.п.).
    5. Дополнительно рассмотреть реализацию наследования шаблонных классов (например, от простого базового класса).
    6. В функции main выполнить действия с шаблонной функцией или классом, которые продемонстрируют работу методов.
    7. Отладить и выполнить полученную программу. Проверить использование специализаций, стандартных типов и аргументов по умолчанию.

Вариант 7: 
Функция для подсчета количества элементов удовлетворяющих определенному условию.


## 7 лабораторная
### Тема: Контейнеры объектов. Обработка исключительных ситуаций.

Общие требования к выполнению работы
1.     Рассмотреть теоретические сведения по теме лабораторной работы.
2.     Создать проект консольной программы.
    3. Реализовать класс-контейнер и класс-итератор согласно варианту. 
    4. Перемещение по контейнеру и изменение элементов контейнера осуществлять только через итераторы. Для итераторов предусмотреть возможность доступа к произвольному элементу контейнера. Элементом контейнера является класс, заданный по варианту в 2 лабораторной работе.
    5. Реализовать сортировку контейнера согласно варианту. Продемонстрировать работу заданных итераторов.
    6. Любую работу с данными реализовывать через обработку исключительных ситуаций. Реализовать перегрузку операторов для контейнера и итератора. Для обработки всех ошибочных ситуаций использовать конструкцию try…catch(). Реализовать собственный класс обработки исключительной ситуации. Рассмотреть замену обработчиков функций terminate() и unexpected() собственными функциями.
    7. Для ассоциативных контейнеров либо ключ, либо значение должны быть уникальными, так что на свое усмотрение выбирайте уникальное поле.
    8.  Для полученного варианта задания, построить контейнерный шаблонный класс операций над элементами данных, включающий операции:
-- добавления;
-- удаления;
-- поиска;
-- просмотра;
9. Для данного контейнерного класса предусмотреть при формировании элемента задание режима уникальных элементов (т.е. проверку на дублирование значений элементов).
10. В функции main создать три экземпляра шаблонного класса-контейнера для разных типов данных. Работа с этими объектами должна демонстрироваться на следующих операциях: добавить – просмотреть – найти – удалить – найти – просмотреть.
11.  Отладить и выполнить полученную программу. Проверить обработку исключительных ситуаций (например, чтение из пустого стека, дублирование объектов и т.п.).

Вариант 22:
Контейнер: однонаправленный стек.
Итераторы: ввода и обратный.
Сортировка: сортировка вставками.
